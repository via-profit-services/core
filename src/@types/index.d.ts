// Type definitions for @via-profit-services/core
// Project: git@github.com:via-profit-services/core
// Definitions by: Via Profit <https://github.com/via-profit-services>
// Warning: This is not autogenerated definitions!

declare module '@via-profit-services/core' {
  import {
    GraphQLSchema,
    GraphQLError,
    GraphQLFieldResolver,
    GraphQLScalarType,
    ExecutionArgs,
    ExecutionResult,
    GraphQLField,
    GraphQLObjectType,
    GraphQLResolveInfo,
    GraphQLInputObjectType,
    GraphQLInterfaceType,
    GraphQLErrorExtensions,
    GraphQLFormattedError,
    ValidationRule,
    GraphQLEnumType,
  } from 'graphql';
  import http from 'http';
  import { EventEmitter } from 'events';
  import { ReadStream, WriteStream } from 'fs';
  import { ReadableOptions } from 'stream';

  export interface ReadStreamOptions {
    highWaterMark?: ReadableOptions['highWaterMark'];
    encoding?: ReadableOptions['encoding'];
  }

  export interface InitProps {
    /**
     * GraphQL Schema Definition
     * @see: https://graphql.org
     */
    readonly schema: GraphQLSchema;
    /**
     * Persisted Queries map (Object contains key: value pairs). \
     * If persisted queries map is passed, the server will ignore \
     * the query directive in body request and read the map \
     * @see https://relay.dev/docs/en/persisted-queries.html
     */
    readonly persistedQueriesMap?: PersistedQueriesMap;
    /**
     * Used only together with the `persistedQueriesMap` option.\
     * The name of the parameter that will be passed the ID of the query in the Persisted Queries map.
     * \
     * Default: `documentId`
     */
    readonly persistedQueryKey?: string;
    /**
     * Server timezone
     * @deprecated Since version 2.4. Will be deleted in version 3.0. Use the middlewares to store the time zone in the context object
     * \
     * Default: `UTC`
     */
    readonly timezone?: string;
    /**
     * Debug mode \
     * \
     * Default: `false`
     */
    readonly debug?: boolean;

    /**
     * This value will be passed to  method execute of the graphql package as is
     */
    readonly rootValue?: unknown;

    /**
     * Middleware function or array of middlewares
     */
    readonly middleware?: Middleware | Middleware[];

    /**
     * Max field value size for busboy (in bytes)
     */
    readonly maxFieldSize?: number;

    /**
     * For multipart forms, the max file size for busboy (in bytes)
     */
    readonly maxFileSize?: number;

    /**
     * For multipart forms, the max number of file fields for busboy
     */
    readonly maxFiles?: number;
  }

  export interface FilePayload {
    /**
     * Name of the uploaded file
     */
    readonly filename: string;

    /**
     * Mime type of the uploaded file
     */
    readonly mimeType: string;

    /**
     * Encoding of the uploaded file
     */
    readonly encoding: string;

    /**
     * Function to read uploaded file\
     * Example:
     *
     * ```ts
     * import path from 'node:path';
     * import fs from 'node:fs';
     * import {
     *   GraphQLNonNull,
     *   GraphQLList,
     *   GraphQLObjectType,
     *   GraphQLString,
     *   GraphQLInt,
     * } from 'graphql';
     * import {
     *   UploadedFile,
     *   FileUploadScalarType,
     * } from '@via-profit-services/core';
     *
     * const Mutation = new GraphQLObjectType({
     *   name: 'Mutation',
     *   fields: {
     *     uploadFiles: {
     *       description: 'Upload files and get their location, mimeType and size',
     *       type: new GraphQLNonNull(
     *         new GraphQLList(
     *           new GraphQLNonNull(
     *             new GraphQLObjectType({
     *               name: 'UploadedFilePayload',
     *               fields: {
     *                 location: { type: new GraphQLNonNull(GraphQLString) },
     *                 mimeType: { type: new GraphQLNonNull(GraphQLString) },
     *                 size: { type: new GraphQLNonNull(GraphQLInt) },
     *               },
     *             }),
     *           ),
     *         ),
     *       ),
     *       args: {
     *         files: {
     *           type: new GraphQLNonNull(
     *             new GraphQLList(
     *               new GraphQLNonNull(
     *                 // This is where the FileUploadScalarType scalar is used
     *                 FileUploadScalarType,
     *               ),
     *             ),
     *           ),
     *         },
     *       },
     *       resolve: async (_parent, args: { files: UploadedFile[] }) => {
     *         const { files } = args;
     *
     *         // Just response data array
     *         const response: {
     *           location: string;
     *           mimeType: string;
     *         }[] = [];
     *
     *         // Don't forget call this promise
     *         // Uploading files is an asynchronous operation
     *         const filesData = await Promise.all(files);
     *
     *         // Now you can read the files
     *         await filesData.reduce(async (prev, file) => {
     *           await prev;
     *
     *           const readStream = file.createReadStream();
     *           const fileExt = file.mimeType.replace(/\//, '');
     *           const filename = `${Date.now()}.${fileExt}`;
     *           const location = path.resolve(__dirname, `./files/${filename}`);
     *
     *           fs.mkdirSync(path.dirname(location), { recursive: true });
     *           const writeStream = fs.createWriteStream(location);
     *
     *           const writeFile = new Promise<void>(resolve => {
     *             writeStream.on('close', async () => {
     *               response.push({
     *                 location,
     *                 mimeType: file.mimeType,
     *               });
     *               resolve();
     *             });
     *
     *             readStream.pipe(writeStream);
     *           });
     *
     *           await writeFile;
     *         }, Promise.resolve());
     *
     *         return response;
     *       },
     *     },
     *   },
     * });
     * ```
     */
    readonly createReadStream: (options?: ReadStreamOptions) => ReadStream;
    readonly capacitor: WriteStream;
  }

  export type UploadedFile = Promise<FilePayload>;

  interface CoreServiceProps {
    context: Context;
  }

  type MakeGraphQLRequestParams = {
    query: string;
    operationName: ExecutionArgs['operationName'];
    variables: ExecutionArgs['variableValues'];
  };

  export class CoreService {
    props: CoreServiceProps;
    constructor(props: CoreServiceProps);

    /**
     * Send GraphQL request Send to yourself
     */
    makeGraphQLRequest<T = ExecutionResult['data']>(
      params: MakeGraphQLRequestParams,
    ): MaybePromise<ExecutionResult<T>>;

    /**
     * Return current module version
     */
    getVersion(): string;
  }

  /**
   * Execute each middleware
   */
  export type ApplyMiddlewares = (props: {
    middlewares: Middleware[];
    request: http.IncomingMessage;
    stats: CoreStats;
    schema: GraphQLSchema;
    context: Context;
    extensions: GraphQLErrorExtensions;
    config: Configuration;
    validationRule: ValidationRule[];
  }) => Promise<void>;

  export class CoreEmitter extends EventEmitter {
    on(event: 'graphql-error-execute', listener: (errors: readonly GraphQLError[]) => void): this;
    once(event: 'graphql-error-execute', listener: (errors: readonly GraphQLError[]) => void): this;
    addListener(
      event: 'graphql-error-execute',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    removeListener(
      event: 'graphql-error-execute',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    prependListener(
      event: 'graphql-error-execute',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    prependOnceListener(
      event: 'graphql-error-execute',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    emit(event: 'graphql-error-execute', ...args: [errors: readonly GraphQLError[]]): boolean;
    removeAllListeners(event: 'graphql-error-execute'): this;
    listeners(event: 'graphql-error-execute'): Function[];
    listenerCount(event: 'graphql-error-execute'): number;

    on(
      event: 'graphql-error-validate-field',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    once(
      event: 'graphql-error-validate-field',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    addListener(
      event: 'graphql-error-validate-field',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    removeListener(
      event: 'graphql-error-validate-field',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    prependListener(
      event: 'graphql-error-validate-field',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    prependOnceListener(
      event: 'graphql-error-validate-field',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    emit(
      event: 'graphql-error-validate-field',
      ...args: [errors: readonly GraphQLError[]]
    ): boolean;
    removeAllListeners(event: 'graphql-error-validate-field'): this;
    listeners(event: 'graphql-error-validate-field'): Function[];
    listenerCount(event: 'graphql-error-validate-field'): number;

    on(
      event: 'graphql-error-validate-request',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    once(
      event: 'graphql-error-validate-request',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    addListener(
      event: 'graphql-error-validate-request',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    removeListener(
      event: 'graphql-error-validate-request',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    prependListener(
      event: 'graphql-error-validate-request',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    prependOnceListener(
      event: 'graphql-error-validate-request',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    emit(
      event: 'graphql-error-validate-request',
      ...args: [errors: readonly GraphQLError[]]
    ): boolean;
    removeAllListeners(event: 'graphql-error-validate-request'): this;
    listeners(event: 'graphql-error-validate-request'): Function[];
    listenerCount(event: 'graphql-error-validate-request'): number;

    on(
      event: 'graphql-error-validate-schema',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    once(
      event: 'graphql-error-validate-schema',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    addListener(
      event: 'graphql-error-validate-schema',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    removeListener(
      event: 'graphql-error-validate-schema',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    prependListener(
      event: 'graphql-error-validate-schema',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    prependOnceListener(
      event: 'graphql-error-validate-schema',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    emit(
      event: 'graphql-error-validate-schema',
      ...args: [errors: readonly GraphQLError[]]
    ): boolean;
    removeAllListeners(event: 'graphql-error-validate-schema'): this;
    listeners(event: 'graphql-error-validate-schema'): Function[];
    listenerCount(event: 'graphql-error-validate-schema'): number;
  }

  export type MaybePromise<T> = Promise<T> | T;

  export type WithKey<K extends string | number | symbol, ResType> = {
    [key in K]: ResType;
  };

  export type ExtractKeyAsObject = <T, K extends keyof T, D>(
    source: T,
    key: K,
    defaultValue?: D,
  ) => {
    [key in K]: T[K] | D;
  };

  export interface Context {
    /**
     * @deprecated Since version 2.4. Will be deleted in version 3.0.
     */
    readonly timezone: string;

    /**
     * The property services is used to store various services in context
     */
    readonly services: ServicesCollection;

    /**
     * This is a simple [Node Emitter class](https://nodejs.org/api/events.html#class-eventemitter)
     */
    readonly emitter: CoreEmitter;

    /**
     * Incomming HTTP request
     */
    request: http.IncomingMessage;

    /**
     * Graphql schema
     */
    schema: GraphQLSchema;
  }

  export type CoreStats = {
    requestCounter: number;
    readonly startupTime: Date;
  };

  export interface ServicesCollection {
    core: CoreService;
    [key: string]: unknown;
  }

  export type HTTPListener = (
    request: http.IncomingMessage,
    response: http.ServerResponse,
  ) => MaybePromise<GraphqlResponse>;

  export type GraphqlResponse = {
    data?: Record<string, any> | null;
    errors?: readonly GraphQLFormattedError[] | null;
    extensions?: GraphQLExtensions;
  };

  export type GraphQLExtensions = CoreStats & {
    // stats: CoreStats;
    queryTime: number;
    requestCounter: number;
    readonly startupTime: Date;
  };

  export type ApplicationFactory = (props: InitProps) => HTTPListener;

  export type PersistedQueriesMap = Record<string, string>;

  export interface MiddlewareProps {
    readonly config: Configuration;
    readonly stats: CoreStats;
    context: Context;
    validationRule: ValidationRule[];
    request: http.IncomingMessage;
    schema: GraphQLSchema;
    extensions: MiddlewareExtensions;
  }

  export interface MiddlewareExtensions {
    [key: string]: any;
  }

  export type Middleware = (props: MiddlewareProps) => MaybePromise<void>;

  export type Configuration = Required<InitProps>;

  /**
   * GraphQL Cursor connection
   * @see https://facebook.github.io/relay/graphql/connections.htm
   */
  export interface CursorConnection<T> {
    edges: Edge<T>[];
    pageInfo: PageInfo;
  }
  /**
   * GraphQL PageInfo
   * @see https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo
   */
  export interface PageInfo {
    startCursor?: string;
    endCursor?: string;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
  }
  /**
   * GraphQL Node type
   * @see https://facebook.github.io/relay/graphql/connections.htm#sec-Node
   */
  export type Node<T, K extends string = 'id'> = T & {
    [key in K]: string;
  };

  /**
   * GraphQL Edge type
   * @see https://facebook.github.io/relay/graphql/connections.htm#sec-Edge-Types
   */
  export interface Edge<T> {
    node: Node<T>;
    cursor: string;
  }

  // TODO: Remove since v3
  export interface ListResponse<T> {
    /**
     * @deprecated No longer supported
     */
    totalCount?: number;
    /**
     * @deprecated No longer supported
     */
    revert?: boolean;
    offset: number;
    limit: number;
    nodes: Node<T>[];
    orderBy: OrderBy;
    where: Where;
  }

  // TODO: Remove since v3
  export interface CursorConnectionProps<T> {
    nodes: Node<T>[];
    totalCount?: number;
    limit?: number;
    offset?: number;
    orderBy?: OrderBy;
    where?: Where;
    search?: OutputSearch;
    between?: Between;
    revert?: boolean;
  }
  export interface BetweenDate {
    start: Date;
    end: Date;
  }
  export interface BetweenTime {
    start: string;
    end: string;
  }
  export interface BetweenDateTime {
    start: Date;
    end: Date;
  }
  export interface BetweenInt {
    start: number;
    end: number;
  }
  export interface BetweenMoney {
    start: number;
    end: number;
  }
  export interface Between {
    [key: string]: BetweenDate | BetweenTime | BetweenDateTime | BetweenInt | BetweenMoney;
  }

  // TODO: Remove since v3
  export interface InputFilter {
    first?: number;
    offset?: number;
    last?: number;
    after?: string;
    before?: string;
    orderBy?: OrderBy;
    search?: InputSearch;
    between?: Between;
    filter?: InputFilterRecord;
  }

  // TODO: Remove since v3
  export type InputFilterRecord = Record<
    string,
    InputFilterValue | readonly string[] | readonly number[] | readonly boolean[]
  >;

  // TODO: Remove since v3
  export type InputFilterValue = string | number | boolean | null;

  // TODO: Remove since v3
  export type InputSearch =
    | SearchSingleField
    | SearchSingleField[]
    | SearchMultipleFields
    | SearchMultipleFields[];

  // TODO: Remove since v3
  interface SearchSingleField {
    field: string;
    query: string;
  }

  // TODO: Remove since v3
  interface SearchMultipleFields {
    fields: string[];
    query: string;
  }
  export type OutputSearch = {
    field: string;
    query: string;
  }[];

  // TODO: Remove since v3
  export interface OutputFilter {
    limit: number;
    offset: number;
    orderBy: OrderBy;
    where: Where;
    search: OutputSearch | false;
    between: Between;
    revert: boolean;
  }

  // TODO: Remove since v3
  export interface CursorPayload {
    offset: number;
    where: Where;
    between: Between;
    orderBy: OrderBy;
    search: OutputSearch;
  }
  export type OrderBy = {
    field: string;
    direction: DirectionRange;
  }[];

  // TODO: Remove since v3
  export type WhereValue =
    | string
    | number
    | boolean
    | null
    | readonly string[]
    | readonly number[]
    | readonly boolean[]
    | undefined;

  // TODO: Remove since v3
  export type WhereField = [string, WhereAction, WhereValue];

  // TODO: Remove since v3
  export type Where = WhereField[];

  export type RequestBody = {
    operationName?: unknown;
    query?: unknown;
    variables?: Record<string, unknown>;
    [key: string]: unknown;
  };

  export type Source = any;

  type Args = Record<string, unknown>;
  export type MutatedField = GraphQLField<Source, Context, Args> & Record<string, boolean>;
  export type MutatedObjectType = GraphQLObjectType<Source, Context> & Record<string, boolean>;

  export type ResolversWrapperFunction = (props: {
    resolve: GraphQLFieldResolver<Source, Context, Args>;
    source: Source;
    args: Args;
    context: Context;
    info: GraphQLResolveInfo;
  }) => MaybePromise<{
    resolve?: GraphQLFieldResolver<Source, Context, Args>;
    source?: Source;
    args?: Args;
    context?: Context;
    info?: GraphQLResolveInfo;
  }>;

  export type NoopResolver = GraphQLFieldResolver<Source, Context, Args>;

  export type FieldsWrapper = (
    schema: GraphQLSchema,
    wrapper: ResolversWrapperFunction,
    options?: {
      wrapWithoutResolvers?: boolean;
    },
  ) => GraphQLSchema;

  // TODO: Remove since v3
  export type StringToCursor = (str: string) => string;

  // TODO: Remove since v3
  export type CursorToString = (str: string) => string;

  // TODO: Remove since v3
  export type MakeNodeCursor = (cursorName: string, cursorPayload: CursorPayload) => string;

  // TODO: Remove since v3
  export type GetCursorPayload = (cursor: string) => CursorPayload;

  // TODO: Remove since v3
  export type BuildCursorConnection = <T>(
    props: CursorConnectionProps<T>,
    cursorName?: string,
  ) => CursorConnection<T>;

  // TODO: Remove since v3
  export type NodeToEdge = <T>(
    node: Node<T>,
    cursorName: string,
    cursorPayload: CursorPayload,
  ) => Edge<T>;

  // TODO: Remove since v3
  export type ExtractNodeField = <T, K extends keyof Node<T>>(
    nodes: Node<T>[],
    field: K,
  ) => Node<T>[K][];

  // TODO: Remove since v3
  export type ExtractNodeIds = <T>(nodes: Node<T, 'id'>[]) => string[];

  // TODO: Remove since version 3
  export type ArrayOfIdsToArrayOfObjectIds = (array: string[]) => {
    id: string;
  }[];

  // TODO: Remove since version 3
  export type BuildQueryFilter = <T extends InputFilter>(args: T) => OutputFilter;

  export type DirectionRange = 'asc' | 'desc';

  // TODO: Remove since v3
  export type WhereAction =
    | '='
    | '<>'
    | '>'
    | '<'
    | '>='
    | '<='
    | 'in'
    | 'notIn'
    | 'like'
    | 'ilike'
    | 'is null'
    | 'is not null';

  export type BodyParser = (props: {
    request: http.IncomingMessage;
    response: http.ServerResponse;
    config: Configuration;
  }) => Promise<RequestBody>;

  export type MultipartParser = (props: {
    request: http.IncomingMessage;
    response: http.ServerResponse;
    config: Configuration;
  }) => Promise<RequestBody>;

  export type ResolverFactory<
    Data extends Record<string, any> = any,
    Source extends Record<string, any> = any,
    Args extends Record<string, any> = any,
  > = (field: keyof Data) => GraphQLFieldResolver<Source, Context, Args>;

  // TODO: Remove since v3
  export type FieldBuilder = <
    Data extends Record<string, any> = any,
    Source extends Record<string, any> = any,
    Args extends Record<string, any> = any,
  >(
    fields: (keyof Data)[],
    resolverFactory: ResolverFactory<Data, Source, Args>,
  ) => Record<keyof Data, GraphQLFieldResolver<Source, Context, Args>>;

  /**
   * `OutputFilter` containing the default values
   * @deprecated Since version 2.4. Will be deleted in version 3.0
   */
  export const defaultOutputFilter: OutputFilter;

  /**
   * Analogue of https://www.npmjs.com/package/body-parser
   */
  export const bodyParser: BodyParser;
  /**
   * Just encode base64 string
   * _Internal function. Used for GraphQL connection building_
   *
   * ```ts
   * const cursor = stringToCursor(JSON.stringify({ foo: 'bar' }));
   * console.log(cursor); // <-- eyJmb28iOiJiYXIifQ==
   * ```
   * @deprecated Since version 2.4. Will be deleted in version 3.0
   */
  export const stringToCursor: StringToCursor;

  /**
   * Just decode base64 string
   * _Internal function. Used for GraphQL connection building_
   *
   * ```ts
   * const data = cursorToString('eyJmb28iOiJiYXIifQ==');
   * console.log(data); // <-- '{"foo":"bar"}'
   * ```
   *
   * @deprecated Since version 2.4. Will be deleted in version 3.0
   */
  export const cursorToString: CursorToString;

  /**
   * Returns cursor base64 cursor string by name and cursor payload
   *
   * ```ts
   * const cursor = makeNodeCursor('persons-cursor', {
   *   offset: 0,
   *   limit: 15,
   *   where: [],
   *   orderBy: [{
   *     field: 'name',
   *     direction: 'desc',
   *   }],
   * });
   * console.log(cursor); // <-- eyJvZmZzZXQiOjAsImxpbWl0IjoxNSwid2hlcmUiOltdLCJvcmRlckJ5IjpbeyJmaWVsZCI6Im5hbWUiLCJkaXJlY3Rpb24iOiJkZXNjIn1dfS0tLXBlcnNvbnMtY3Vyc29y
   * ```
   * @deprecated Since version 2.4. Will be deleted in version 3.0
   */
  export const makeNodeCursor: MakeNodeCursor;

  /**
   * Convert string to cursor base64 string and return payload
   *
   * ```ts
   * const payload = getCursorPayload('eyJvZmZzZXQiOjAsImxpbWl0IjoxNSwid2hlcmUiOltdLCJvcmRlckJ5IjpbeyJmaWVsZCI6Im5hbWUiLCJkaXJlY3Rpb24iOiJkZXNjIn1dfS0tLXBlcnNvbnMtY3Vyc29y')
   *
   * // {
   * //   offset: 0,
   * //  limit: 15,
   * //  where: [],
   * //  orderBy: [ { field: 'name', direction: 'desc' } ]
   * // }
   *@deprecated Since version 2.4. Will be deleted in version 3.0
   * ```
   */
  export const getCursorPayload: GetCursorPayload;

  /**
   * Returns Relay cursor bundle
   *
   * ```ts
   * const cursorBundle = buildCursorConnection({
   *   totalCount: 3,
   *   offset: 0,
   *   limit: 2,
   *   nodes: [
   *     { id: '1', name: 'Ivan', createdAt: new Date(), updatedAt: new Date() },
   *     { id: '2', name: 'Stepan', createdAt: new Date(), updatedAt: new Date() },
   *   ]
   * }, 'persons-cursor');
   *
   * // response -> {
   * //   totalCount: 3,
   * //   edges: [
   * //     {
   * //       node: { id: '1', name: 'Ivan', ... },
   * //       cursor:  'eyJvZmZzZXQiOjEsImxpbWl0Ijoy...'
   * //     },
   * //     {
   * //       node: { id: '2', name: 'Stepan', ... },
   * //       cursor:  'eyJvZmZzZXQiOjIsImxpbWl0Ij...'
   * //     }
   * //   ],
   * //   pageInfo: {
   * //     startCursor:  'eyJvZmZzZXQiOjEsImxpbWl0Ijoy...',
   * //     endCursor:  'eyJvZmZzZXQiOjIsImxpbWl0Ij...',
   * //     hasPreviousPage: false,
   * //     hasNextPage: true
   * //   }
   * // }
   * @deprecated Since version 2.4. Will be deleted in version 3.0
   * ```
   */
  export const buildCursorConnection: BuildCursorConnection;

  /**
   * Wrap node to cursor object
   *
   * ```ts
   * const filter = {
   *   offset: 0,
   *   limit: 15,
   *   where: [],
   *   orderBy: [{
   *     field: 'name',
   *     direction: 'desc',
   *   }],
   * }
   *
   * // Get persons list
   * const persons = await service.getPersons(filter);
   *
   * // Map all persons to compile the edge for each
   * const edges = persons.map((person) => {
   *
   *   // You should passed node, cursor name and filter params
   *   return nodeToEdge(person, 'persons-cursor', filter);
   * });
   * console.log(edges); // <-- [{ cursor: 'XGHJGds', node: { id: '1', name: 'Ivan' } }]
   *
   * ```
   * @deprecated Since version 2.4. Will be deleted in version 3.0
   */
  export const nodeToEdge: NodeToEdge;

  /**
   * Return array of fields of node
   *
   * ```ts
   * const persons = [
   *   {id: '1', name: 'Ivan'},
   *   {id: '2', name: 'Stepan'},
   *   {id: '3', name: 'Petruha'},
   * ];
   *
   * const names = extractNodeField(persons, 'name');
   * console.log(names); // <-- ['Ivan', 'Stepan', 'Petruha']
   *
   * @deprecated Since version 2.4. Will be deleted in version 3.0.
   * ```
   */
  export const extractNodeField: ExtractNodeField;

  /**
   * Returns node IDs array
   *
   * ```ts
   * const ids = extractNodeIds([
   *   {id: '1', name: 'Ivan'},
   *   {id: '2', name: 'Stepan'},
   *   {id: '3', name: 'Petruha'},
   * ]);
   *
   * console.log(ids); // <-- ['1', '2', '3'];
   * @deprecated Since version 2.4. Will be deleted in version 3.0.
   *
   * ```
   */
  export const extractNodeIds: ExtractNodeIds;

  /**
   * Format array of IDs to object with id key\
   * Example:
   *
   * ```ts
   * const ids = arrayOfIdsToArrayOfObjectIds(['1', '2', '3']);
   *
   * console.log(ids); // <-- [{id: '1'}, {id: '2'}, {id: '3'}]
   * @deprecated Since version 2.4. Will be deleted in version 3.0.
   *
   * ```
   */
  export const arrayOfIdsToArrayOfObjectIds: ArrayOfIdsToArrayOfObjectIds;

  /**
   * Convert input filter (partial from GraphQL request) to persist filter
   * @deprecated Since version 2.4. Will be deleted in version 3.0. Use your own way of validating the transmitted values
   */
  export const buildQueryFilter: BuildQueryFilter;

  /**
   * Creates an object containing a specific key\
   * Example:
   *
   * ```ts
   * const source = {
   *   foo: 'Foo',
   *   bar: 12,
   * };
   * const record = extractKeyAsObject(source, 'bar');
   *
   * console.log(record); // <-- { bar: 12 }
   * ```
   * @deprecated Since version 2.4. Will be deleted in version 3.0
   */
  export const extractKeyAsObject: ExtractKeyAsObject;

  /**
   * Wrap types resolvers in schema.\
   * You can wrap types without resolvers - will be created noop-resolver to wrap the field
   * **Note:** The resolver function should return all the received parameters.\
   * Example:
   * ```ts
   * const { httpListener } = await factory({
   *   schema,
   *   middleware: [
   *     ({ schema }) => ({
   *       schema: fieldsWrapper(schema, (params) => {
   *         const { resolver, source, args, context, info } = params;
   *         // Do something
   *
   *         return params;
   *       })
   *     }),
   *   ],
   * });
   * ```
   */
  export const fieldsWrapper: FieldsWrapper;

  /**
   * Build GraphQL field resolver.\
   * This function takes as its first argument an array of keys\
   * of the Type that needs to be resolved.\
   * The second argument is the function to which the key name will be passed.\
   * The function should return a value of the type for this key\
   * This is useful when you need to modify  the resolver response.
   *
   * SDL:
   * ```graphql
   * type User {
   *   id: ID!
   *   name: String!
   * }
   * ```
   *\
   * Resolver:
   * ```ts
   * const User = fieldBuilder(
   *  ['id', 'name'],
   *  field => async (parent, args, context) => {
   *    const user = parent;
   *
   *    if (field === 'name') {
   *      // compatible
   *      return user.name.replace(/\b\w/g, l => l.toUpperCase());
   *    }
   *
   *    return user[field];
   *  },
   * );
   * ```
   * @deprecated Since version 2.4. Will be deleted in version 3.0
   */
  export const fieldBuilder: FieldBuilder;

  export const graphqlHTTPFactory: ApplicationFactory;

  export type ServerErrorType =
    | 'graphql-error-execute'
    | 'graphql-error-validate-field'
    | 'graphql-error-validate-request'
    | 'graphql-error-validate-schema';

  class ServerError extends Error {
    readonly graphqlErrors: readonly GraphQLError[];
    readonly errorType: ServerErrorType;
    constructor(graphqlErrors: readonly GraphQLError[], errorType: ServerErrorType);
  }

  export const FileUploadScalarType: GraphQLScalarType;
  export const DateScalarType: GraphQLScalarType;
  export const DateTimeScalarType: GraphQLScalarType;
  export const EmailAddressScalarType: GraphQLScalarType;

  /**
   * The value is stored in the smallest monetary
   * unit (kopecks, cents, etc.). Real type - Int. E.g.
   * For 250 USD this record returns value as 250000 (250$ * 100Â¢)\
   * \
   * It is assumed that you will store the value of this type in its smallest value All calculations in the same way.
   * \
   * Usage example:
   * ```ts
   * import { GraphQLObjectType, GraphQLNonNull, GraphQLID } from 'graphql';
   * import { Context, MoneyScalarType } from '@via-profit-services/core';
   * 
   * const Ticket = new GraphQLObjectType<unknown, Context>({
   *   name: 'Ticket',
   *   fields: {
   *     price: {
   *       type: new GraphQLNonNull(MoneyScalarType),
   *     },
   *     id: {
   *       type: new GraphQLNonNull(GraphQLID),
   *     },
   *   },
   * });
   * 
   * export default Ticket;
   * ```
   */
  export const MoneyScalarType: GraphQLScalarType;
  export const TimeScalarType: GraphQLScalarType;
  export const VoidScalarType: GraphQLScalarType;
  export const URLScalarType: GraphQLScalarType;
  export const JSONScalarType: GraphQLScalarType;
  export const JSONObjectScalarType: GraphQLScalarType;

  export const BetweenDateInputType: GraphQLInputObjectType;
  export const BetweenDateTimeInputType: GraphQLInputObjectType;
  export const BetweenIntInputType: GraphQLInputObjectType;
  export const BetweenMoneyInputType: GraphQLInputObjectType;
  export const BetweenTimeInputType: GraphQLInputObjectType;


  /**
   * GraphQL Connection spec. interface\
   * \
   * Interface implements the SDL:
   * ```graphql
   * interface Connection {
   *   pageInfo: PageInfo!
   *   edges: [Edge!]!
   * }
   * ```
   * \
   * Usage example:
   * ```ts
   * import { GraphQLList, GraphQLNonNull, GraphQLObjectType } from 'graphql';
   * import { PageInfoType, ConnectionInterfaceType } from '@via-profit-services/core';
   * 
   * import MyEdge from './MyEdge';
   * 
   * const MyConnection = new GraphQLObjectType({
   *   name: 'MyConnection',
   *   interfaces: [ConnectionInterfaceType],
   *   fields: () => ({
   *     pageInfo: { type: new GraphQLNonNull(PageInfoType) },
   *     edges: {
   *       type: new GraphQLNonNull(
   *         new GraphQLList(
   *           new GraphQLNonNull(MyEdge)
   *         )
   *       )
   *     },
   *   }),
   * });
   * 
   * export default MyConnection;
   * ```
   */
  export const ConnectionInterfaceType: GraphQLInterfaceType;

  /**
   * GraphQL Edge spec. interface\
   * According to the specification, the Edge must contain
   * at least an `cursor` field with the type of `String!`
   * and the `node` field with type of your Node
   * \
   * Interface implements the SDL:
   * ```graphql
   * interface Edge {
   *   node: SomeNode!
   *   cursor: String!
   * }
   * ```
   * \
   * Usage example:
   * ```ts
   * import { GraphQLNonNull, GraphQLObjectType, GraphQLString } from 'graphql';
   * import { EdgeInterfaceType } from '@via-profit-services/core';
   * 
   * import MyNode from './MyNode';
   * 
   * const MyEdge = new GraphQLObjectType({
   *   name: 'MyEdge',
   *   interfaces: [EdgeInterfaceType],
   *   fields: () => ({
   *     cursor: { type: new GraphQLNonNull(GraphQLString) },
   *     node: { type: new GraphQLNonNull(MyNode) },
   *   }),
   * });
   * 
   * export default MyEdge;
   * ```
   */
  export const EdgeInterfaceType: GraphQLInterfaceType;

  /**
   * GraphQL Error interface\
   * \
   * Interface implements the SDL:
   * ```graphql
   * interface Error {
   *   name: String!
   *   msg: String!
   * }
   * ```
   * \
   * Usage example:
   * ```ts
   * import { GraphQLObjectType, GraphQLNonNull, GraphQLString } from 'graphql';
   * import { ErrorInterfaceType } from '@via-profit-services/core';
   * 
   * const MyError = new GraphQLObjectType({
   *   name: 'MyError',
   *   interfaces: () => [ErrorInterfaceType],
   *   fields: {
   *     name: { type: new GraphQLNonNull(GraphQLString) },
   *     msg: { type: new GraphQLNonNull(GraphQLString) },
   *   },
   * });
   * 
   * export default MyError;
   * ```
   */
  export const ErrorInterfaceType: GraphQLInterfaceType;


  /**
   * GraphQL Node spec. interface\
   * According to the specification, the Node must contain at least an `id` field with the `ID!` type\
   * \
   * Interface implements the SDL:
   * ```graphql
   * interface Node {
   *   id: String!
   * }
   * ```
   * \
   * Usage example:
   * ```ts
   * import { GraphQLID, GraphQLNonNull, GraphQLObjectType, GraphQLString } from 'graphql';
   * import { Context, DateTimeScalarType, NodeInterfaceType } from '@via-profit-services/core';
   * 
   * const MyNode = new GraphQLObjectType<unknown, Context>({
   *   name: 'MyNode',
   *   interfaces: () => [NodeInterfaceType],
   *   fields: () => ({
   *     id: { type: new GraphQLNonNull(GraphQLID) },
   *     name: { type: new GraphQLNonNull(GraphQLString) },
   *   }),
   * });
   * 
   * export default MyNode;
   * ```
   */
  export const NodeInterfaceType: GraphQLInterfaceType;

  /**
   * GraphQL type for the data ordering\
   * \
   * Interface implements the SDL:
   * ```graphql
   * enum OrderDirection {
   *   """Sort the query results in a top to bottom style (e.g.: A->Z)"""
   *   ASC
   * 
   *   """Sort the query results in a bottom to top style (e.g.: Z->A)"""
   *   DESC
   * }
   * ```
   * \
   * Usage example:
   * ```ts
   * import { GraphQLInputObjectType, GraphQLEnumType, GraphQLNonNull } from 'graphql';
   * import { OrderDirectionType } from '@via-profit-services/core';
   * 
   * const MyOrderBy = new GraphQLInputObjectType({
   *   name: 'MyOrderBy',
   *   fields: () => ({
   *     direction: { type: new GraphQLNonNull(OrderDirectionType) },
   *     field: {
   *       type: new GraphQLNonNull(
   *         new GraphQLEnumType({
   *           name: 'BlockOrderField',
   *           values: {
   *             NAME: { value: 'name' },
   *             TYPE: { value: 'type' },
   *           },
   *         }),
   *       ),
   *     },
   *   }),
   * });
   * 
   * export default MyOrderBy;
   * ```
  */
  export const OrderDirectionType: GraphQLEnumType;

  /**
   * GraphQL PageInfo spec. type\
   * \
   * Interface implements the SDL:
   * ```graphql
   * type PageInfo {
   *   hasPreviousPage: Boolean!
   *   hasNextPage: Boolean!
   *   startCursor: String
   *   endCursor: String
   * }
   * ```
   * \
   * Usage example:
   * ```ts
   * import { GraphQLList, GraphQLNonNull, GraphQLObjectType } from 'graphql';
   * import { PageInfoType, ConnectionInterfaceType } from '@via-profit-services/core';
   * 
   * import MyEdge from './MyEdge';
   * 
   * const MyConnection = new GraphQLObjectType({
   *   name: 'MyConnection',
   *   interfaces: [ConnectionInterfaceType],
   *   fields: () => ({
   *     pageInfo: { type: new GraphQLNonNull(PageInfoType) },
   *     edges: { type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(MyEdge))) },
   *   }),
   * });
   * 
   * export default MyConnection;
   * ```
   */
  export const PageInfoType: GraphQLObjectType;

  /**
   * @deprecated Since version 2.4. Will be deleted in version 3.0.
   */
  export const DEFAULT_SERVER_TIMEZONE: string;

  export const DEFAULT_PERSISTED_QUERY_KEY: string;
  export const DEFAULT_MAX_FIELD_SIZE: number;
  export const DEFAULT_MAX_FILE_SIZE: number;
  export const DEFAULT_MAX_FILES: number;
}
