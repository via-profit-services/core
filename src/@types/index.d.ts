// Type definitions for @via-profit-services/core
// Project: git@github.com:via-profit-services/core
// Definitions by: Via Profit <https://github.com/via-profit-services>
// Warning: This is not autogenerated definitions!

declare module '@via-profit-services/core' {
  import {
    GraphQLSchema,
    GraphQLError,
    GraphQLFieldResolver,
    GraphQLScalarType,
    ExecutionArgs,
    ExecutionResult,
    GraphQLField,
    GraphQLObjectType,
    GraphQLResolveInfo,
    GraphQLInputObjectType,
    GraphQLInterfaceType,
    GraphQLErrorExtensions,
    GraphQLFormattedError,
    ValidationRule,
    GraphQLEnumType,
  } from 'graphql';
  import http from 'http';
  import { EventEmitter } from 'events';
  import { ReadStream, WriteStream } from 'fs';
  import { ReadableOptions } from 'stream';

  export interface ReadStreamOptions {
    highWaterMark?: ReadableOptions['highWaterMark'];
    encoding?: ReadableOptions['encoding'];
  }

  export interface InitProps {
    /**
     * GraphQL Schema Definition
     * @see: https://graphql.org
     */
    readonly schema: GraphQLSchema;
    /**
     * Persisted Queries map (Object contains key: value pairs). \
     * If persisted queries map is passed, the server will ignore \
     * the query directive in body request and read the map \
     * @see https://relay.dev/docs/en/persisted-queries.html
     */
    readonly persistedQueriesMap?: PersistedQueriesMap;
    /**
     * Used only together with the `persistedQueriesMap` option.\
     * The name of the parameter that will be passed the ID of the query in the Persisted Queries map.
     * \
     * Default: `documentId`
     */
    readonly persistedQueryKey?: string;
    /**
     * Debug mode \
     * \
     * Default: `false`
     */
    readonly debug?: boolean;

    /**
     * This value will be passed to  method execute of the graphql package as is
     */
    readonly rootValue?: unknown;

    /**
     * Middleware function or array of middlewares
     */
    readonly middleware?: Middleware | Middleware[];

    /**
     * Max field value size for busboy (in bytes)
     */
    readonly maxFieldSize?: number;

    /**
     * For multipart forms, the max file size for busboy (in bytes)
     */
    readonly maxFileSize?: number;

    /**
     * For multipart forms, the max number of file fields for busboy
     */
    readonly maxFiles?: number;
  }

  export interface FilePayload {
    /**
     * Name of the uploaded file
     */
    readonly filename: string;

    /**
     * Mime type of the uploaded file
     */
    readonly mimeType: string;

    /**
     * Encoding of the uploaded file
     */
    readonly encoding: string;

    /**
     * Function to read uploaded file\
     * Example:
     *
     * ```ts
     * import path from 'node:path';
     * import fs from 'node:fs';
     * import {
     *   GraphQLNonNull,
     *   GraphQLList,
     *   GraphQLObjectType,
     *   GraphQLString,
     *   GraphQLInt,
     * } from 'graphql';
     * import {
     *   UploadedFile,
     *   FileUploadScalarType,
     * } from '@via-profit-services/core';
     *
     * const Mutation = new GraphQLObjectType({
     *   name: 'Mutation',
     *   fields: {
     *     uploadFiles: {
     *       description: 'Upload files and get their location, mimeType and size',
     *       type: new GraphQLNonNull(
     *         new GraphQLList(
     *           new GraphQLNonNull(
     *             new GraphQLObjectType({
     *               name: 'UploadedFilePayload',
     *               fields: {
     *                 location: { type: new GraphQLNonNull(GraphQLString) },
     *                 mimeType: { type: new GraphQLNonNull(GraphQLString) },
     *                 size: { type: new GraphQLNonNull(GraphQLInt) },
     *               },
     *             }),
     *           ),
     *         ),
     *       ),
     *       args: {
     *         files: {
     *           type: new GraphQLNonNull(
     *             new GraphQLList(
     *               new GraphQLNonNull(
     *                 // This is where the FileUploadScalarType scalar is used
     *                 FileUploadScalarType,
     *               ),
     *             ),
     *           ),
     *         },
     *       },
     *       resolve: async (_parent, args: { files: UploadedFile[] }) => {
     *         const { files } = args;
     *
     *         // Just response data array
     *         const response: {
     *           location: string;
     *           mimeType: string;
     *         }[] = [];
     *
     *         // Don't forget call this promise
     *         // Uploading files is an asynchronous operation
     *         const filesData = await Promise.all(files);
     *
     *         // Now you can read the files
     *         await filesData.reduce(async (prev, file) => {
     *           await prev;
     *
     *           const readStream = file.createReadStream();
     *           const fileExt = file.mimeType.replace(/\//, '');
     *           const filename = `${Date.now()}.${fileExt}`;
     *           const location = path.resolve(__dirname, `./files/${filename}`);
     *
     *           fs.mkdirSync(path.dirname(location), { recursive: true });
     *           const writeStream = fs.createWriteStream(location);
     *
     *           const writeFile = new Promise<void>(resolve => {
     *             writeStream.on('close', async () => {
     *               response.push({
     *                 location,
     *                 mimeType: file.mimeType,
     *               });
     *               resolve();
     *             });
     *
     *             readStream.pipe(writeStream);
     *           });
     *
     *           await writeFile;
     *         }, Promise.resolve());
     *
     *         return response;
     *       },
     *     },
     *   },
     * });
     * ```
     */
    readonly createReadStream: (options?: ReadStreamOptions) => ReadStream;
    readonly capacitor: WriteStream;
  }

  export type UploadedFile = Promise<FilePayload>;

  interface CoreServiceProps {
    context: Context;
  }

  type MakeGraphQLRequestParams = {
    query: string;
    operationName: ExecutionArgs['operationName'];
    variables: ExecutionArgs['variableValues'];
  };

  export class CoreService {
    props: CoreServiceProps;
    constructor(props: CoreServiceProps);

    /**
     * Send GraphQL request Send to yourself
     */
    makeGraphQLRequest<T = ExecutionResult['data']>(
      params: MakeGraphQLRequestParams,
    ): MaybePromise<ExecutionResult<T>>;

    /**
     * Return current module version
     */
    getVersion(): string;
  }

  /**
   * Execute each middleware
   */
  export type ApplyMiddlewares = (props: {
    middlewares: Middleware[];
    request: http.IncomingMessage;
    stats: CoreStats;
    schema: GraphQLSchema;
    context: Context;
    extensions: GraphQLErrorExtensions;
    config: Configuration;
    validationRule: ValidationRule[];
  }) => Promise<void>;

  export class CoreEmitter extends EventEmitter {
    on(event: 'graphql-error-execute', listener: (errors: readonly GraphQLError[]) => void): this;
    once(event: 'graphql-error-execute', listener: (errors: readonly GraphQLError[]) => void): this;
    addListener(
      event: 'graphql-error-execute',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    removeListener(
      event: 'graphql-error-execute',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    prependListener(
      event: 'graphql-error-execute',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    prependOnceListener(
      event: 'graphql-error-execute',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    emit(event: 'graphql-error-execute', ...args: [errors: readonly GraphQLError[]]): boolean;
    removeAllListeners(event: 'graphql-error-execute'): this;
    listeners(event: 'graphql-error-execute'): Function[];
    listenerCount(event: 'graphql-error-execute'): number;

    on(
      event: 'graphql-error-validate-field',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    once(
      event: 'graphql-error-validate-field',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    addListener(
      event: 'graphql-error-validate-field',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    removeListener(
      event: 'graphql-error-validate-field',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    prependListener(
      event: 'graphql-error-validate-field',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    prependOnceListener(
      event: 'graphql-error-validate-field',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    emit(
      event: 'graphql-error-validate-field',
      ...args: [errors: readonly GraphQLError[]]
    ): boolean;
    removeAllListeners(event: 'graphql-error-validate-field'): this;
    listeners(event: 'graphql-error-validate-field'): Function[];
    listenerCount(event: 'graphql-error-validate-field'): number;

    on(
      event: 'graphql-error-validate-request',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    once(
      event: 'graphql-error-validate-request',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    addListener(
      event: 'graphql-error-validate-request',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    removeListener(
      event: 'graphql-error-validate-request',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    prependListener(
      event: 'graphql-error-validate-request',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    prependOnceListener(
      event: 'graphql-error-validate-request',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    emit(
      event: 'graphql-error-validate-request',
      ...args: [errors: readonly GraphQLError[]]
    ): boolean;
    removeAllListeners(event: 'graphql-error-validate-request'): this;
    listeners(event: 'graphql-error-validate-request'): Function[];
    listenerCount(event: 'graphql-error-validate-request'): number;

    on(
      event: 'graphql-error-validate-schema',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    once(
      event: 'graphql-error-validate-schema',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    addListener(
      event: 'graphql-error-validate-schema',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    removeListener(
      event: 'graphql-error-validate-schema',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    prependListener(
      event: 'graphql-error-validate-schema',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    prependOnceListener(
      event: 'graphql-error-validate-schema',
      listener: (errors: readonly GraphQLError[]) => void,
    ): this;
    emit(
      event: 'graphql-error-validate-schema',
      ...args: [errors: readonly GraphQLError[]]
    ): boolean;
    removeAllListeners(event: 'graphql-error-validate-schema'): this;
    listeners(event: 'graphql-error-validate-schema'): Function[];
    listenerCount(event: 'graphql-error-validate-schema'): number;
  }

  export type MaybePromise<T> = Promise<T> | T;

  export type WithKey<K extends string | number | symbol, ResType> = {
    [key in K]: ResType;
  };

  export type ExtractKeyAsObject = <T, K extends keyof T, D>(
    source: T,
    key: K,
    defaultValue?: D,
  ) => {
    [key in K]: T[K] | D;
  };

  export interface Context {
    /**
     * The property services is used to store various services in context
     */
    readonly services: ServicesCollection;

    /**
     * This is a simple [Node Emitter class](https://nodejs.org/api/events.html#class-eventemitter)
     */
    readonly emitter: CoreEmitter;

    /**
     * Incomming HTTP request
     */
    request: http.IncomingMessage;

    /**
     * Graphql schema
     */
    schema: GraphQLSchema;
  }

  export type CoreStats = {
    requestCounter: number;
    readonly startupTime: Date;
  };

  export interface ServicesCollection {
    core: CoreService;
    [key: string]: unknown;
  }

  export type HTTPListener = (
    request: http.IncomingMessage,
    response: http.ServerResponse,
  ) => MaybePromise<GraphqlResponse>;

  export type GraphqlResponse = {
    data?: Record<string, any> | null;
    errors?: readonly GraphQLFormattedError[] | null;
    extensions?: GraphQLExtensions;
  };

  export type GraphQLExtensions = CoreStats & {
    // stats: CoreStats;
    queryTime: number;
    requestCounter: number;
    readonly startupTime: Date;
  };

  export type ApplicationFactory = (props: InitProps) => HTTPListener;

  export type PersistedQueriesMap = Record<string, string>;

  export interface MiddlewareProps {
    readonly config: Configuration;
    readonly stats: CoreStats;
    context: Context;
    validationRule: ValidationRule[];
    request: http.IncomingMessage;
    schema: GraphQLSchema;
    extensions: MiddlewareExtensions;
  }

  export interface MiddlewareExtensions {
    [key: string]: any;
  }

  export type Middleware = (props: MiddlewareProps) => MaybePromise<void>;

  export type Configuration = Required<InitProps>;

  /**
   * GraphQL Cursor connection
   * @see https://facebook.github.io/relay/graphql/connections.htm
   */
  export interface CursorConnection<T> {
    edges: Edge<T>[];
    pageInfo: PageInfo;
  }
  /**
   * GraphQL PageInfo
   * @see https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo
   */
  export interface PageInfo {
    startCursor?: string;
    endCursor?: string;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
  }
  /**
   * GraphQL Node type
   * @see https://facebook.github.io/relay/graphql/connections.htm#sec-Node
   */
  export type Node<T, K extends string = 'id'> = T & {
    [key in K]: string;
  };

  /**
   * GraphQL Edge type
   * @see https://facebook.github.io/relay/graphql/connections.htm#sec-Edge-Types
   */
  export interface Edge<T> {
    node: Node<T>;
    cursor: string;
  }

  export interface BetweenDate {
    start: Date;
    end: Date;
  }
  export interface BetweenTime {
    start: string;
    end: string;
  }
  export interface BetweenDateTime {
    start: Date;
    end: Date;
  }
  export interface BetweenInt {
    start: number;
    end: number;
  }
  export interface BetweenMoney {
    start: number;
    end: number;
  }
  export interface Between {
    [key: string]: BetweenDate | BetweenTime | BetweenDateTime | BetweenInt | BetweenMoney;
  }

  export type RequestBody = {
    operationName?: unknown;
    query?: unknown;
    variables?: Record<string, unknown>;
    [key: string]: unknown;
  };

  export type Source = any;

  type Args = Record<string, unknown>;
  export type MutatedField = GraphQLField<Source, Context, Args> & Record<string, boolean>;
  export type MutatedObjectType = GraphQLObjectType<Source, Context> & Record<string, boolean>;

  export type ResolversWrapperFunction = (props: {
    resolve: GraphQLFieldResolver<Source, Context, Args>;
    source: Source;
    args: Args;
    context: Context;
    info: GraphQLResolveInfo;
  }) => MaybePromise<{
    resolve?: GraphQLFieldResolver<Source, Context, Args>;
    source?: Source;
    args?: Args;
    context?: Context;
    info?: GraphQLResolveInfo;
  }>;

  export type NoopResolver = GraphQLFieldResolver<Source, Context, Args>;

  export type FieldsWrapper = (
    schema: GraphQLSchema,
    wrapper: ResolversWrapperFunction,
    options?: {
      wrapWithoutResolvers?: boolean;
    },
  ) => GraphQLSchema;

  export type BodyParser = (props: {
    request: http.IncomingMessage;
    response: http.ServerResponse;
    config: Configuration;
  }) => Promise<RequestBody>;

  export type MultipartParser = (props: {
    request: http.IncomingMessage;
    response: http.ServerResponse;
    config: Configuration;
  }) => Promise<RequestBody>;

  export type ResolverFactory<
    Data extends Record<string, any> = any,
    Source extends Record<string, any> = any,
    Args extends Record<string, any> = any,
  > = (field: keyof Data) => GraphQLFieldResolver<Source, Context, Args>;

  /**
   * Analogue of https://www.npmjs.com/package/body-parser
   */
  export const bodyParser: BodyParser;

  export const graphqlHTTPFactory: ApplicationFactory;

  export type ServerErrorType =
    | 'graphql-error-execute'
    | 'graphql-error-validate-field'
    | 'graphql-error-validate-request'
    | 'graphql-error-validate-schema';

  class ServerError extends Error {
    readonly graphqlErrors: readonly GraphQLError[];
    readonly errorType: ServerErrorType;
    constructor(graphqlErrors: readonly GraphQLError[], errorType: ServerErrorType);
  }

  export const FileUploadScalarType: GraphQLScalarType;
  export const DateScalarType: GraphQLScalarType;
  export const DateTimeScalarType: GraphQLScalarType;
  export const EmailAddressScalarType: GraphQLScalarType;

  /**
   * The value is stored in the smallest monetary
   * unit (kopecks, cents, etc.). Real type - Int. E.g.
   * For 250 USD this record returns value as 250000 (250$ * 100¢)\
   * \
   * It is assumed that you will store the value of this type in its smallest value All calculations in the same way.
   * \
   * Usage example:
   * ```ts
   * import { GraphQLObjectType, GraphQLNonNull, GraphQLID } from 'graphql';
   * import { Context, MoneyScalarType } from '@via-profit-services/core';
   *
   * const Ticket = new GraphQLObjectType<unknown, Context>({
   *   name: 'Ticket',
   *   fields: {
   *     price: {
   *       type: new GraphQLNonNull(MoneyScalarType),
   *     },
   *     id: {
   *       type: new GraphQLNonNull(GraphQLID),
   *     },
   *   },
   * });
   *
   * export default Ticket;
   * ```
   */
  export const MoneyScalarType: GraphQLScalarType;
  export const TimeScalarType: GraphQLScalarType;
  export const VoidScalarType: GraphQLScalarType;
  export const URLScalarType: GraphQLScalarType;
  export const JSONScalarType: GraphQLScalarType;
  export const JSONObjectScalarType: GraphQLScalarType;

  export const BetweenDateInputType: GraphQLInputObjectType;
  export const BetweenDateTimeInputType: GraphQLInputObjectType;
  export const BetweenIntInputType: GraphQLInputObjectType;
  export const BetweenMoneyInputType: GraphQLInputObjectType;
  export const BetweenTimeInputType: GraphQLInputObjectType;

  /**
   * GraphQL Connection spec. interface\
   * \
   * Interface implements the SDL:
   * ```graphql
   * interface Connection {
   *   pageInfo: PageInfo!
   *   edges: [Edge!]!
   * }
   * ```
   * \
   * Usage example:
   * ```ts
   * import { GraphQLList, GraphQLNonNull, GraphQLObjectType } from 'graphql';
   * import { PageInfoType, ConnectionInterfaceType } from '@via-profit-services/core';
   *
   * import MyEdge from './MyEdge';
   *
   * const MyConnection = new GraphQLObjectType({
   *   name: 'MyConnection',
   *   interfaces: [ConnectionInterfaceType],
   *   fields: () => ({
   *     pageInfo: { type: new GraphQLNonNull(PageInfoType) },
   *     edges: {
   *       type: new GraphQLNonNull(
   *         new GraphQLList(
   *           new GraphQLNonNull(MyEdge)
   *         )
   *       )
   *     },
   *   }),
   * });
   *
   * export default MyConnection;
   * ```
   */
  export const ConnectionInterfaceType: GraphQLInterfaceType;

  /**
   * GraphQL Edge spec. interface\
   * According to the specification, the Edge must contain
   * at least an `cursor` field with the type of `String!`
   * and the `node` field with type of your Node
   * \
   * Interface implements the SDL:
   * ```graphql
   * interface Edge {
   *   node: SomeNode!
   *   cursor: String!
   * }
   * ```
   * \
   * Usage example:
   * ```ts
   * import { GraphQLNonNull, GraphQLObjectType, GraphQLString } from 'graphql';
   * import { EdgeInterfaceType } from '@via-profit-services/core';
   *
   * import MyNode from './MyNode';
   *
   * const MyEdge = new GraphQLObjectType({
   *   name: 'MyEdge',
   *   interfaces: [EdgeInterfaceType],
   *   fields: () => ({
   *     cursor: { type: new GraphQLNonNull(GraphQLString) },
   *     node: { type: new GraphQLNonNull(MyNode) },
   *   }),
   * });
   *
   * export default MyEdge;
   * ```
   */
  export const EdgeInterfaceType: GraphQLInterfaceType;

  /**
   * GraphQL Error interface\
   * \
   * Interface implements the SDL:
   * ```graphql
   * interface Error {
   *   name: String!
   *   msg: String!
   * }
   * ```
   * \
   * Usage example:
   * ```ts
   * import { GraphQLObjectType, GraphQLNonNull, GraphQLString } from 'graphql';
   * import { ErrorInterfaceType } from '@via-profit-services/core';
   *
   * const MyError = new GraphQLObjectType({
   *   name: 'MyError',
   *   interfaces: () => [ErrorInterfaceType],
   *   fields: {
   *     name: { type: new GraphQLNonNull(GraphQLString) },
   *     msg: { type: new GraphQLNonNull(GraphQLString) },
   *   },
   * });
   *
   * export default MyError;
   * ```
   */
  export const ErrorInterfaceType: GraphQLInterfaceType;

  /**
   * GraphQL Node spec. interface\
   * According to the specification, the Node must contain at least an `id` field with the `ID!` type\
   * \
   * Interface implements the SDL:
   * ```graphql
   * interface Node {
   *   id: String!
   * }
   * ```
   * \
   * Usage example:
   * ```ts
   * import { GraphQLID, GraphQLNonNull, GraphQLObjectType, GraphQLString } from 'graphql';
   * import { Context, DateTimeScalarType, NodeInterfaceType } from '@via-profit-services/core';
   *
   * const MyNode = new GraphQLObjectType<unknown, Context>({
   *   name: 'MyNode',
   *   interfaces: () => [NodeInterfaceType],
   *   fields: () => ({
   *     id: { type: new GraphQLNonNull(GraphQLID) },
   *     name: { type: new GraphQLNonNull(GraphQLString) },
   *   }),
   * });
   *
   * export default MyNode;
   * ```
   */
  export const NodeInterfaceType: GraphQLInterfaceType;

  /**
   * GraphQL type for the data ordering\
   * \
   * Interface implements the SDL:
   * ```graphql
   * enum OrderDirection {
   *   """Sort the query results in a top to bottom style (e.g.: A->Z)"""
   *   ASC
   *
   *   """Sort the query results in a bottom to top style (e.g.: Z->A)"""
   *   DESC
   * }
   * ```
   * \
   * Usage example:
   * ```ts
   * import { GraphQLInputObjectType, GraphQLEnumType, GraphQLNonNull } from 'graphql';
   * import { OrderDirectionType } from '@via-profit-services/core';
   *
   * const MyOrderBy = new GraphQLInputObjectType({
   *   name: 'MyOrderBy',
   *   fields: () => ({
   *     direction: { type: new GraphQLNonNull(OrderDirectionType) },
   *     field: {
   *       type: new GraphQLNonNull(
   *         new GraphQLEnumType({
   *           name: 'BlockOrderField',
   *           values: {
   *             NAME: { value: 'name' },
   *             TYPE: { value: 'type' },
   *           },
   *         }),
   *       ),
   *     },
   *   }),
   * });
   *
   * export default MyOrderBy;
   * ```
   */
  export const OrderDirectionType: GraphQLEnumType;

  /**
   * GraphQL PageInfo spec. type\
   * \
   * Interface implements the SDL:
   * ```graphql
   * type PageInfo {
   *   hasPreviousPage: Boolean!
   *   hasNextPage: Boolean!
   *   startCursor: String
   *   endCursor: String
   * }
   * ```
   * \
   * Usage example:
   * ```ts
   * import { GraphQLList, GraphQLNonNull, GraphQLObjectType } from 'graphql';
   * import { PageInfoType, ConnectionInterfaceType } from '@via-profit-services/core';
   *
   * import MyEdge from './MyEdge';
   *
   * const MyConnection = new GraphQLObjectType({
   *   name: 'MyConnection',
   *   interfaces: [ConnectionInterfaceType],
   *   fields: () => ({
   *     pageInfo: { type: new GraphQLNonNull(PageInfoType) },
   *     edges: { type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(MyEdge))) },
   *   }),
   * });
   *
   * export default MyConnection;
   * ```
   */
  export const PageInfoType: GraphQLObjectType;

  export const DEFAULT_PERSISTED_QUERY_KEY: string;
  export const DEFAULT_MAX_FIELD_SIZE: number;
  export const DEFAULT_MAX_FILE_SIZE: number;
  export const DEFAULT_MAX_FILES: number;
}
